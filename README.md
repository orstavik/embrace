# embrace

## How to load embrace and run embrace?

```html
<head>
<script type="importmap">
  {
    "imports": {
      "DollarDots": "https://cdn.jsdelivr.net/gh/orstavik/embrace@26.02.08.14/DollarDots.js?external=Diff",
      "Diff": "https://cdn.jsdelivr.net/gh/orstavik/making-a@25.09.12/difference.js"
    }
  }
</script>
<script type="module" src="https://cdn.jsdelivr.net/gh/orstavik/embrace@26.02.08.14/auto.js"></script>
<script type="module">
  import { renderUnder } from "DollarDots";

  while (renderUnder(document.body, {data: 123}))
    await new Promise(requestAnimationFrame);
</script>
</head>
<body>
<!-- :: if($.a) -->
<ol>
  <li>${$.a}</li>
  <li>${$.b}</li>
</ol>
<!--::-->
</body>
```

1. You can use a cdn to load the repo: 
   * https://cdn.jsdelivr.net/gh/orstavik/embrace@26.02.08.14/auto.js
   * https://esm.sh/gh/orstavik/embrace@26.02.08.14/DollarDots.js?external=Diff
   * https://esm.sh/gh/orstavik/embrace@26.02.08.14/compile.js
   * Att!! The DollarDots.js has a dependency on Diff.js: https://cdn.jsdelivr.net/gh/orstavik/making-a@25.09.12/difference.js
2. The `auto.js` compiles all the templates inside `document.body` automatically at startup and register them using `import { register } from "DollarDots";`.
3. To run the template engine in the browser, use `import { renderUnder } from "DollarDots";` and then call `renderUnder(domNode, state)`. If you use the same `domNode` on a later call, the templates will be reused.

## live demo in iframe

<iframe src="/test/basic/one.html"></iframe>

<iframe srcdoc="
    <html>
    <body>
        <h1>Hello!</h1>
        <p>This content is embedded via the srcdoc attribute.</p>
        <a href='https://example.com'>A link within the iframe</a>
    </body>
    </html>">
</iframe>

## Description

```html
<link rel="modulepreload" href="/DollarDots.js">
<link rel="modulepreload" href="https://cdn.jsdelivr.net/gh/orstavik/making-a@25.09.12/difference.js">
<script type="importmap" preload="Diff">
  {
    "imports": {
      "DollarDots": "/DollarDots.js",
      "Diff": "https://cdn.jsdelivr.net/gh/orstavik/making-a@25.09.12/difference.js"
    }
  }
</script>
<script type="module" src="/auto.js"></script>
<script type="module">
  import { renderUnder } from "DollarDots";

  const data = await (await fetch("SerSeaEpi.json")).json();
  while (renderUnder(document.body, data))
    await new Promise(requestAnimationFrame);
</script>
```

The project has 3 main entry points:
1. DollarDots.js (provides the `register()` and `renderUnder()` functions). Has a dependency on `Diff`.
2. `auto.js` (No dependencies itself, but it outputs code must get `import {register} from "DollarDots";`)
3. `Compile.js` (no dependencies)

* The output code (indirectly created by `auto.js` or `Compile.js`) is `<script type="module">` with code  that calls `register` for each template definition. (See below)

`DollarDots.js` is the registry, the core library, and the renderer. It is used when template definitions are registered (generated by as text output from e.g. `auto.js` or `Compile.js`) and when dom nodes with these template comment tags retrieve definitions and renders it on screen.

## `auto.js`

To generate compiled template definitions, you can use the `Compile.js` or `auto.js` scripts. The `auto.js` script will generate compiled template definitions for all the templates in the `document.body`. The `Compile.js` script is used manually to generate compiled template definitions for a subset of the templates in the `document.body` or from strings containing template definitions. The `auto.js` script is standalone, but it produces a script that is appended dynamically to `document.body` that in turn `import { register } from "DollarDots";` and then calls `register` for each template definition.

```html
<script type="module" src="/auto.js"></script>
<!-- produces and adds dynamically a script that looks something like this: -->
<script type="module">
import { register } from "DollarDots";

register({
  id: "id_0b172ff5809b4629bbb964a304bb0034",
  hydra: ($, $$) => {for([$.episode_i, $.episode] of $.season.episodes.entries()) $$();},
  templateString: "<!--::,-->\n            <!-- ${JSON.stringify($.season, null, 2)} -->\n            <li>episode #${$.episode_i + 1}: ${$.episode} produced by ${$.producer}.</li>\n            ",
  innerHydras: [
    { path: [ 2 ], hydra: $ => ` ${JSON.stringify($.season, null, 2)} ` },
    { path: [ 4, 0 ], hydra: $ => `episode #${$.episode_i + 1}: ${$.episode} produced by ${$.producer}.` }
  ]
});
register({
  id: "id_4bd44ae2b79a496fa80f092b9890865f",
  hydra: ($, $$) => {if(($.season_i + 1) % 2) $$();},
  templateString: "<!--::,-->\n          <ol>\n            <!--:: id_0b172ff5809b4629bbb964a304bb0034--><!--::-->\n          </ol>\n          ",
  innerHydras: [
    {
      id: "id_0b172ff5809b4629bbb964a304bb0034",
      path: [ 2, 1 ],
      hydra: ($, $$) => {for([$.episode_i, $.episode] of $.season.episodes.entries()) $$();}
    }
  ]
});
//# sourceURL=DDDefs0.js
</script>
```

## `DollarDots.js`

To activate and render templates, we use `DollarDots.js`. The `DollarDots.js` has a single function `renderUnder(root, data)` that renders all the templates in the `root` with the given `data`. It succeeds silently, but outputs a string with the `id` of any template that it encounters that is not yet defined.

```html
<script type="module">
  import { renderUnder } from "DollarDots";

  const data = await (await fetch("SerSeaEpi.json")).json();
  while (renderUnder(document.body, data))
    await new Promise(requestAnimationFrame);
  //When the data object changes, you can call renderUnder again to update the DOM.
</script>
```

## `importmap`

```html
<link rel="modulepreload" href="/DollarDots.js">
<link rel="modulepreload" href="https://cdn.jsdelivr.net/gh/orstavik/making-a@25.09.12/difference.js">
<script type="importmap" preload="Diff">
  {
    "imports": {
      "DollarDots": "/DollarDots.js",
      "Diff": "https://cdn.jsdelivr.net/gh/orstavik/making-a@25.09.12/difference.js"
    }
  }
</script>
```

To get everything to work (efficiently) in the browser, we need to use `modulepreload` and `importmap`. The registerAndRenderer should always be named `DollarDots` in the importmap as compiled code requires it.

## work in progress
1. class for the Def. Call it StampType.
2. DDRender. The extractUnusedInnerReusables(Def) is untested!!
   make a test for the extractUnusedInnerReusables(Def). This will require reuse of common template ids.
   this is actually a little tricky. We can reuse the same dom if the insides of the templates are identical, 
   regardless of the if and for. This means that we actually would like the start and end nodes not be part of the same system.
3. fix the getInstance function so it is also a Stamp. That way we can hide #nodes and #start in the Stamp.
4. 